import java.sql.SQLException;

public class Singleton {
	public static void main(String[] args) throws SQLException {
		
	}
}

class Database {
    // O campo para armazenar a instância singleton deve ser declarado como estático.
    private static Database instance;

    // O construtor do singleton deve sempre ser privado para prevenir chamadas diretas de construção com o operador `new`.
    private Database() {
        // Algum código de inicialização, como a conexão com um servidor de banco de dados.
        // ...
    }

    // O método estático que controla o acesso à instância do singleton.
    public static synchronized Database getInstance() {
        if (instance == null) {
            // Certifique-se de que a instância ainda não foi inicializada por outra thread enquanto esta estiver esperando pela liberação do `lock`.
            if (instance == null) {
                instance = new Database();
            }
        }
        return instance;
    }

    // Finalmente, qualquer singleton deve definir alguma lógica de negócio que deve ser executada em sua instância.
    public void query(String sql) {
        // Por exemplo, todas as solicitações à base de dados de uma aplicação passam por esse método.
        // Portanto, você pode colocar a lógica de throttling ou cache aqui.
        // ...
        System.out.println("Executando consulta: " + sql);
    }
}

class Application {
    public static void main(String[] args) {
        // Obtenha uma instância do Singleton Database
        Database foo = Database.getInstance();
        foo.query("SELECT ...");

        // Outra variável `bar` vai conter o mesmo objeto que a variável `foo`.
        Database bar = Database.getInstance();
        bar.query("SELECT ...");
    }
}