import java.sql.SQLException;

public class Singleton {
	public static void main(String[] args) throws SQLException {

	}
}

class Database {
	// O campo para armazenar a instância singleton deve ser declarado como
	// estático.
	private static Database instance;

	// O construtor do singleton deve sempre ser privado para prevenir chamadas
	// diretas de construção com o operador `new`.
	private Database() {
		// Algum código de inicialização, como a conexão com um servidor de banco de
		// dados.
		// ...
	}

	// O método estático que controla o acesso à instância do singleton.
	public static synchronized Database getInstance() {
		if (instance == null) {
			// Certifique-se de que a instância ainda não foi inicializada por outra thread
			// enquanto esta estiver esperando pela liberação do `lock`.
			if (instance == null) {
				instance = new Database();
			}
		}
		return instance;
	}

	// Finalmente, qualquer singleton deve definir alguma lógica de negócio que deve
	// ser executada em sua instância.
	public void query(String sql) {
		// Por exemplo, todas as solicitações à base de dados de uma aplicação passam
		// por esse método.
		// Portanto, você pode colocar a lógica de throttling ou cache aqui.
		// ...
		System.out.println("Executando consulta: " + sql);
	}
}

class Application {
	public static void main(String[] args) {
		// Obtenha uma instância do Singleton Database
		Database foo = Database.getInstance();
		foo.query("SELECT ...");

		// Outra variável `bar` vai conter o mesmo objeto que a variável `foo`.
		Database bar = Database.getInstance();
		bar.query("SELECT ...");
	}
}